#define F_CPU 1200000UL
#include <avr/io.h>
#include <avr/interrupt.h>
#include <util/delay.h>

volatile uint8_t Rece_bit;
volatile uint8_t rec;
volatile uint8_t usart_r;
volatile uint8_t coef;

ISR(INT0_vect)
{rec=1;} // Прерывание чисто для определения стартового бита при приеме,
// используется редко, можно сюда повесить что-либо еще

//------------------------------------------------------------------------
// Единственный Таймер, используется для формирования четких промежуток
 // между битами, как при приеме так и при передачи
ISR(TIM0_COMPA_vect)//Прерывание по совпадению с числом регистра COMPA
{	TIMSK0=0x00;//отключить прерывание по совпадению с OCR0A
	TCCR0B=0x00;  //отключить таймер
	OCR0A=0; //число сравнения с счетчиком = 0      
	TCNT0=0;//таймер начинает отсчет от 0
	TIMSK0=0x04; // включить прерывание по совпадению с OCR0A
	// Значение "сброс при совпадении" загружается каждый раз из переменной
	OCR0A=coef;      // Можно быстро менять скорости UART
	TCCR0B=0x01;// частота таймера = частота микроконтроллера
	Rece_bit=1;
}

int UART_receiv(void)
{
	uint8_t a;
	usart_r=0;
	
	MCUCR=0x02; // INT0 Interrupt. Падающий фронт на пине INT0 генерирует запрос прерывания
	GIMSK=0x40; // INT0 Interrupt. Внешнее прерывание INT0 включено
	while(rec==0); // Ждать, пока не случится стартовый бит
	MCUCR=0; // INT0 Interrupt. Низкий уровень на пине INT0 генерирует запрос прерывания
	GIMSK=0; // INT0 Interrupt. Все источники внешних прерываний отключены
	coef=62;//запись числа в переменную для регистра сравнения OCR0A
	//(хотя лучше бы подошло число 62,5(значение считывалось бы ровно на половине импульса)
	TCNT0=0x00; //задаем начальное число, с которого начнет счет таймер - 0
	//Когда таймер работает, по каждому импульсу тактового сигнала значение TCNT0 изменяется на единицу.
	TIMSK0=0x04;//разрешение прерывания по совпадению с числом регистра OCR0A
	OCR0A=coef;
	TCCR0B=0x01;//частота таймера = частота микроконтроллера
	rec=0;//обнуление флага появления стартового бита
	while(PINB1==1);
	for(a=0; a<8; a++)//запись в переменную usart_r данных принятых по UART
	{
		while(Rece_bit==0);//ждем пока не получим следующий бит
		if(PINB1==1)// если на 1 пине присутствует положительный потенциал - 	
		{usart_r|=(1<<7);}//то записать единицу в 7 бит переменной usart_r 
			
		else {usart_r &=~(1<<7);} // а если 0, то записать в тот же бит ноль
			
		usart_r=usart_r>>1;
		Rece_bit=0;
		
		}

	return usart_r;
	
}

int main(void)
{
	DDRB&=~(1<<1); //хххх ххх0
	DDRB|=(1<<0); //хххх хх10
	DDRB|=(1<<2);
	PORTB&=~(1<<1);
	PORTB|=(1<<0);
	_delay_ms(500);
	PORTB&=~(1<<0);
	_delay_ms(500);
	PORTB|=(1<<0);
	_delay_ms(500);
	PORTB&=~(1<<0);
	_delay_ms(500);
	asm("sei"); //разрешение прерываний
	while(1)
	{	UART_receiv();
		if(usart_r==0b00110000){PORTB|=(1<<2);}//если прислали единичку, то просто засветится светодиод
		else
		{
		PORTB|=(1<<0);
		_delay_ms(500);
		PORTB&=~(1<<0);
		_delay_ms(500);
		}
			
	}
}